
\appendices

\section{Table of notations}
\label{appendix:notations}

Table~\ref{table:notations} summarizes the notations used throughout
this paper. For the sake of clarity, we divide them into three
categories: network, \process, and message.


\begin{table*}
  \centering
  \caption{\label{table:notations}Notation table.}
  \begin{tabularx}{\textwidth}{@{}lll@{}}
    \toprule
    Notation & Short & Description \\
    \midrule

    $G$ & \underline{G}raph    & Represents a network.\\
    $E$ & \underline{E}dges    & Represents the set of asynchronous communication links.\\
    $V$ & \underline{V}ertices & Represents the set of nodes, or processes.\\
    $\pi_{xz}$ and $\Pi_{xz}$  & \underline{p}ath and best \underline{P}ath & List of contiguous edges from \Process $x$ to \Process $z$.\\
    $|\pi_{xz}|$ and $|\Pi_{xz}|$ & sum of path weights & Positive sum of weights of the path.\\
    $w_{xy}$     & \underline{w}eight & Positive weight of the edge $\langle x, y \rangle$.\\
    
    \midrule

    $\sigma_x$  & \underline{s}tate     & The local state of \Process $x$.\\
    $b_x(m)$    & \underline{b}roadcast & \Process $x$ creates a new message $m$ that must be delivered by all \processes.\\
    $d_{x}(m)$  & \underline{d}eliver   & \Process $x$ delivers the message $m$.\\
    $r_y(m)$ or $r_{yx}(m)$  & \underline{r}eceive   & \Process $y$ receives the message $m$ from any neighboring node or \Process $x$ if specified.\\
    $s_{xy}(m)$ & \underline{s}end      & \Process $x$ sends the message $m$ to \Process $y$.\\
    $f_x(m)$    & \underline{f}orward   & \Process $x$ forwards the message $m$ to its neighbors.\\
    $m \oplus \sigma$   & aggregator    & Aggregates $\sigma$ into the metadata of message $m$.\\
    $\phi(\mu, \sigma)$ & predicate \underline{f}unction & Checks the metadata $\mu$ using the state $\sigma$.\\
    $\eventually P$     & eventually    & Eventually predicate $P$ is true.\\
    $e_1 \rightarrow e_2$ & happens before  & The event $e_1$ happened before the event $e_2$. Delivery, sending, or receipt are events.\\
    $D_x$ & \underline{d}elivered & Set of delivered messages by \Process $x$.\\
    
    \midrule

    $\alpha_x^d$ or $\alpha_{\pi_{xz}}^d$      & \underline{a}dd source & Message that notifies the adding of Source $x$ in the network.\\
    $\delta_x$   & source \underline{d}eletion & Message that notifies the deletion of Source $x$, or the detection by \Process $x$ of a possible source deletion.\\
    $\mathcal{S}(m)$ & \underline{S}tale message & Message $m$ conveys stale control information since its broadcaster broadcast a newer message.\\
    
    \bottomrule
  \end{tabularx}
\end{table*}



\section{Proof of Theorem~\ref{theo:fb}}
\label{appendix:fb}

\begin{proof}
  Whenever a \process~$s$ becomes a source, it broadcasts hence
  delivers its own message $d_s(\alpha_{s}^{|\pi_{ss}|})$. Whatever
  its set of received messages, it acknowledges that it belongs to its
  own partition $P_s$ since $\alpha_{s}^{|\pi_{ss}|} = \min D_s$ and
  it remains forever since $|\pi_{ss}|$ is its greatest lower bound.
  \noindent Such a source forwards its notification to its neighbors.
  Every neighbor eventually receives its notification since
  communication links are reliable. Whatever the order of received
  messages $R_x$ at neighboring \process~$x$, total order ensures that
  it delivers notifications $\alpha_s^{d}$ when
  $d= |\pi_{ss}| + w_{sx} = \min |\pi_{s'x}|$ where $\min |\pi_{s'x}|$
  is the lightest weight of $x$ to any source $s'$, $s'$ being $s$ in
  this case.
  \noindent Among these neighbors, at least those that fulfill the
  latest condition forward their respective notification.  By
  transitivity, the message originating from $s$ reaches all
  \processes that belong to $P_s$ at least through their respective
  lightest path: $\small\smash{\forall y \in V, s, s' \in S: \min
    |\pi_{s y}| < \min |\pi_{s' y}| \implies \eventually
    d_{y}(\alpha_{s}^{\min |\pi_{sy}|})}$. When the system becomes
  quiescent, \ie no \process becomes source anymore, every \process
  eventually acknowledges the partition it belongs to, \ie \processes
  eventually reach consistent partitioning together. In addition, the
  protocol terminates: a \process never delivers hence forwards a
  message after it received, delivered, and forwarded the message of
  its closest source from its lightest path.
\end{proof}



\section{Proof of Theorem~\ref{theo:fbfsdcp}}
\label{appendix:fbfsdcp}

\begin{proof}
  Detection triggers forwarding of staleness downstream which
  completes the case study of Lemma~\ref{lem:detector} by ensuring
  that, when a source broadcasts its staleness notification, all
  \processes that belong to its partition eventually deliver such a
  staleness notification. All downstream bordering \processes also
  eventually receive such a staleness notification and echo back their
  best delivered message. This triggers another competition as in
  Theorem~\ref{theo:fb} for the \processes that delivered the
  staleness notification.
\end{proof}



%% \section{Related work summary}

%% Table~\ref{table:relatedwork} provides a summary of state-of-the-art
%% approaches along with the reason they fail to enable quick content
%% indexing in large scale dynamic systems.


%% \input{input/tablerelatedwork.tex}
