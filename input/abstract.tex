\begin{abstract}
  %% Context and problem
  Although the holy grail to store and manipulate data in Edge
  infrastructures is yet to be found, state-of-the-art approaches
  demonstrated the relevance of replication strategies that bring
  content closer to consumers: The latter enjoy better response time
  while the volume of data passing through the network decreases
  overall.
  %% Although, there is no major solution to store and manipulate data in
  %% Edge infrastructures yet, existing proposals demonstrated the
  %% relevance of appropriate replication strategies to bring contents
  %% closer to consumers, reducing the impact of the latency as well as
  %% the volume of data passing through the network overall.  
  Unfortunately, locating the closest replica of a specific content
  requires indexing \emph{every live} replica along with its
  \emph{location}. 
  %
  %Current proposals built on a centralized service face scalability
  %issues, single point of failure, as well as latency penalities where
  %locating replicas may effectively take more time than actually
  %downloading contents. Instead, data consumer \processes must
  %maintain an up-to-date index themselves. Unfortunately, maintaining
  %an index of all live replicas at every \process would prove overly
  %costly in terms of memory and generated traffic, especially in large
  %scale dynamic systems where \processes create and destroy replicas
  %at any time.
  % 
  Relying on remote services for such a aim,  enters in contradiction with the
  properties of Edge infrastructures as locating replicas may
  effectively take more time than actually downloading content.  At
  the opposite, maintaining such an index at every \process would
  prove overly costly in terms of memory and traffic, especially since
  \processes can create and destroy replicas at any time.
  
  %%% Our proposal
  \noindent In this paper, we abstract the content indexation challenge
  as a distributed partitioning problem: every \process only indexes
  its closest replica, and connected \processes with a similar index
  compose a partition. Our decentralized implementation \NAME is
  \begin{inparaenum}[(i)]
  \item efficient, for it uses partitions to lock down the traffic
    generated by its operations to relevant \processes, yet it
  \item guarantees that every \process eventually acknowledges its
    partition despite concurrent operations.
  \end{inparaenum}
  %% When a \node replicates a content, it notifies all \nodes (new
  %% members of its partition) that are closer from it than any other
  %% replica; When a \node destroys a replica, it notifies members of
  %% its partition to switch to another closer partition. \NAME
  %% guarantees that eventually, every \process knows its best
  %% partition, hence its closest replica, despite concurrent
  %% operations and receipt orders.
  Our prototype, implemented on top of PeerSim, shows that \NAME
  scales well in terms of generated messages and termination
  time. 

  %% \NAME is a crazy contribution
  \color{red} \NAME can constitute a novel building block for
  geo-distributed services, \eg sharing the locations of 
  web object replicas to allow nodes benefit from neighborhood downloads,
  resource discovery in the vicinity of a region, etc.

%  javascript objects)
%  we envision is
%  the sharing of web objects regularly used in social networks (including viral picture/video but also css,
%  javascript objects): instead of contacting CDN nodes, it
%  would be possible to retrieve objects closer and so mitigate the
%  traffic overall.
  
  %% As
  %% such, \NAME can constitute a new building block for geo-distributed
  %% services.
\end{abstract}

\begin{IEEEkeywords}
  Edge infrastructures, decentralized content indexing, scoped
  broadcast, logical partitioning protocol
\end{IEEEkeywords}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "../paper"
%%% ispell-local-dictionary: "english"
%%% End: 
