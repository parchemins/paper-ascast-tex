
\section{Background and motivation}
\label{sec:background}

Fog infrastructures are distributed systems comprising heterogeneous
machines interconnected by communication links.

\begin{definition}[Fog infrastructure]
  A fog infrastructure is a \underline{g}raph $G(V, E)$ of
  \underline{v}ertices $V$ and bidirectional \underline{e}dges $E \in
  V \times V$. Edges have symmetric \underline{w}eights $w_{ij} =
  w_{ij}$ with $i, j \in V$.
\end{definition}

\begin{definition}[Logical partition]
  A logical \underline{p}artition $P_s$ originated at a
  \underline{s}ource process $s \in V$ is a set of interconnected
  processes that do not belong to another logical partition. The set
  of sources is $S \subseteq V$.
\end{definition}

Processes belong to logical partitions depending on path lengths. When
weights are latency or hop numbers, the optimal partitioning consists
in processing the multiple destinations shortest path at each process
\REF.

\begin{definition}[Shortest path]
  A \underline{p}ath $\pi_{ij}$ from Process $i$ to Process $j$ is a
  sequence of vertices $[i, k_1, k_2, \ldots k_n, j]$ with $\forall
  0\leq m \leq n, \langle \pi_{ij}[m], \pi_{ij}[m+1] \rangle \in
  E$. Shortest \underline{p}aths $\Pi_{ij}$ are sets of paths such
  that there exists no lower sum of weights $|\Pi_{ij}|$ from $i$ to
  $j$.
\end{definition}

\begin{definition}[Optimal partitioning]
  The optimal partitioning $\mathcal{P}$ is a set of logical
  partitions such that each process belongs to a logical partition
  comprising its closest source process.  $\forall p \in P_{s_1\in S},
  \nexists P_{s_2 \in S}$ such that $|\Pi_{s_1p}| > |\Pi_{s_2p}|$.
\end{definition}

Processes use reliable asynchronous message passing to reach optimal
partitioning together. Process $s$ generates a message
$\alpha_s^0$. Upon \underline{r}eceipt $r_i(\alpha_s^{w})$, Process
$i$ knows that Process $s$ created a partition at a path length of
$w$. Process $i$ may choose to \underline{d}eliver $d_i(\alpha_s^{w})$
if it improves its partitioning. Process $i$ may choose to propagate
its change through \underline{b}roadcast $b_i(\alpha_s^w)$.  Without
global knowledge, processes only rely on their own behavior to deduce
the behavior of their neighbor processes.

\begin{definition}[\label{def:transitivedelivery}Transitive delivery]
  Transitive delivery ensures the system eventually converges to
  optimal partitioning:
  \begin{inparaenum}[(i)]
  \item (\textbf{termination}) processes do not need to propagate
    operations they do not deliver: $\forall \langle i, j \rangle \in
    E, \neg d_i(\alpha_{s}^w)\implies \neg
    d_j(\alpha_{s}^{w+w_{ij}})$;
  \item (\textbf{propagation}) operations delivered by a process may
    also benefit neighbor processes: $\forall \langle i, j \rangle \in
    E, d_i(\alpha_{s}^{w_1}) \implies
    d_j(\alpha_{s}^{w_1+w_{ij}}) \vee
    d_j(\alpha_{*}^{w_2 < w_1 + w_{ij}})$.
  \end{inparaenum}
\end{definition}


\begin{figure*}
  \begin{center}
    \subfloat[Part A][\label{fig:addA}Both Process $a$ and
      Process $c$ initiate a partition.
      $w_{ab} = 1.5$; $w_{bc} = w_{cd} = w_{bd} = 1$.]{\input{input/figaddA.tex}}
    \hspace{5pt}
    \subfloat[Part B][\label{fig:addB}Messages transit through communication
      links and carry increasing weights.]{\input{input/figaddB.tex}}
    \hspace{5pt}
    \subfloat[Part C][\label{fig:addC}Process $b$ receives and forwards
      $\alpha_{c}^{1}$ then discards $\alpha_{a}^{1.5}$, for the latter distance
      is higher.]{\input{input/figaddC.tex}}
    \hspace{5pt}
    \subfloat[Part D][\label{fig:addD}Processes $b$, $c$, and $d$ discard
      incoming messages. The system converged to optimal partitions.]{
      \input{input/figaddD.tex}}
    \caption{\label{fig:add}Simple accumulation in messages makes the
      system converge to optimal partitions with contained
      broadcast.}
  \end{center}
\end{figure*}

\begin{algorithm}
  \input{input/algoadd.tex}
  \caption{\label{algo:add}Adding a partition by Process $p$.}
\end{algorithm}


Algorithm~\ref{algo:add} shows the instructions that implement the
rules of Definition~\ref{def:transitivedelivery} to converge towards
optimal partitioning. Figure~\ref{fig:add} illustrates its behavior on
a system comprising 4 processes $a$, $b$, $c$, and $d$. Two processes
$a$ and $c$ concurrently create a partition. They initialize their own
state with the lowest possible bound $0$ (see
Line~\ref{line:lowestbound}), and send a message to each of their
neighbors by accumulating the corresponding edge weight (see
Line~\ref{line:accumulator}). In Figure~\ref{fig:addC}, Process $b$
receives $\alpha_{c}^{1}$. Since it improves its own partition
distance, it keeps it and forwards it to its neighbors. Process $b$
discards $\alpha_{b}^{1.5}$, for it does not improve its partition
distance. Processes $c$ and $d$ will never hear of Process $a$'s
partition. At scale, it saves bandwidth by limiting generated traffic
to subsets of processes. In Figure~\ref{fig:addD}, processes discard
last transiting messages. The system converged to the optimal
partitioning.  Transitive relationships ensure that each process gets
its closest source while accumulation of weights ensures that messages
propagation terminates.  Interestingly, while the receipt order of
messages does not impact on local control information
($r_b(\alpha_a^{1.5}) \cdot r_b(\alpha_a^{1}) \Leftrightarrow
r_b(\alpha_a^{1}) \cdot r_b(\alpha_a^{1.5}) \implies
\TODO{d_b(\alpha_a^{1})}$), it impacts on control information
broadcast in the network ($r_b(\alpha_a^{1.5}) \cdot r_b(\alpha_a^{1})
\implies b_b(\alpha_{b}^{1.5}) \cdot b_b(\alpha_{b}^{1})$ while
$r_b(\alpha_a^{1}) \cdot r_b(\alpha_a^{1.5}) \implies
b_b(\alpha_a^{1})$).

While only adding logical partitions to the distributed system is
straightforward, removing them introduces additional complexity. 

\begin{definition}[Dynamic optimal partitioning]
  A dynamic optimal partitioning is an optimal partitioning where the
  set of sources $S$ does not monotonically increase. Process $i$
  joins the set of sources by adding its partition $\alpha_i^{0}$ and
  leaves the set of sources by removing its partition $\delta_i$.
\end{definition}

\TODO{Figure~\ref{fig:del} shows that.}

One could solve this issue by using a conflict-free replicated data
type for set data structures, then deliver and broadcast all
operations to all processes~\REF. However, this would be costly in
terms of generated traffic with some processes delivering and
broadcasting unrelated to their partitions \TODO{(include locality)}.
One could also solve this issue by removing partitions that were not
advertised for a defined time~\REF. However, relying on physical
timeout could lead to either premature removals of partitions when
they are still operating; or slow convergence where processes believe
they belong to a partition that was removed.


\begin{figure*}
  \begin{center}
    \subfloat[Part A][\label{fig:delA}Both Process $a$ and
      Process $c$ initiate then remove a partition.
      $w_{ab} = 1.5$; $w_{bc} = w_{cd} = w_{bd} = 1$.]{\input{input/figdelA.tex}}
    \hspace{5pt}
    \subfloat[Part B][\label{fig:delB}Process $b$ and Process $d$ receive and deliver
      messages based on their weights. $a$'s partition propagates to all processes.]
             {\input{input/figdelB.tex}}
    \hspace{5pt}
    \subfloat[Part C][\label{fig:delC}Process $c$'s partition reach $b$ and $d$.
      Its removal shortly follows. Process $b$ does not have any control
      information about partitions any more.]{\input{input/figdelC.tex}}
    \hspace{5pt}
    \subfloat[Part D][\label{fig:delD}Processes discard remaining messages.
      Process $b$ does not deliver $\delta_a$, for it already removed $a$ when
      Partition $c$ dominated it. Processes $c$ and $d$ remain in an incorrect
      partition.]{\input{input/figdelD.tex}}
  \end{center}
  \caption{\label{fig:del}Partition removals cannot rely only on
    current partition, for it may lead to inconsistent partitioning.}
\end{figure*}

\begin{problem}[Consistent partitioning]
  \TODO{How to enable \emph{consistent} dynamic optimal partitioning
    with contained broadcast?}
\end{problem}

\TODO{Next Section presents our approach that solves this problem
  statement by relying only on logical control information.}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "../paper"
%%% ispell-local-dictionary: "english"
%%% End: 

