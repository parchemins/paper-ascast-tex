
\section{Introduction}

There is an ongoing evolution of storing data from the cloud to the
edges of the network. Either because it is where it has been created
and it is too expensive to be transmitted through the network, or
because it has been replicated to bring data closer to the end users
~\cite{shi2016edge, foggy_cache, cachier}.
%
To favour this transition, the design and the development of building
blocks to manage data sets across Edge infrastructures have been
investigated for the last few years \cite{confais2017performance,
  confais2017object, fogstore, hasenburg2020towards}.  Although these
systems, provide good properties such as favouring network traffic
confinement by writting data locally and replicating contents
according to the effective needs, determining the location where to
get the content might be more expensive than retrieving the content
itself.
%
Indeed, those systems, when not using a centralized index stored in a
Cloud, rely on a Distributed Hash Table (DHT) across the different
nodes composing the infrastructure: When a client wants to access a
specific content, it has to perform a request to a remote process to
determine from which node(s) it will retrieve the content.  Once it has
retrieved the content, a local replica
is created to improve the performance for future accesses and the
process in charge of maintaining the index is contacted once again to reflect this
new location.
%

%This strategy has two majors drawbacks :
%\begin{itemize}
%  \item (i) the lookup penalty: the network latency to reach this
%    remote node incurs an additional delay~\cite{asrese2019measuring,
%      doan2019tracing} to get the object before
%    being able to start its downloading ;
%  \item (ii) the selection of the node(s) from which the content is
%    returned: due to the lack of information that would allow the  a request to each process storing a
%%    replica is perfomed in
%\end{itemize}

Such a protocol contradicts with the objective of Edge
infrastructures that aims at reducing the impact of the
latency as well as the volume of data passing through the network:
\begin{itemize}
  \item In addition to hot spot and partitioning issues, accessing a
    remote node to find the location(s) of a content incurs an
    additional delay~\cite{asrese2019measuring, doan2019tracing} to
    get the object, before being able to start its downloading.
  \item There is no information to select the ``best'' node among the
     possible candidates from which the content  could be
     retrieved. In most cases, this results in parallel requests performed by the client node to
     each candidate with the goal of retrieving the content as efficient
     as possible.
\end{itemize}    

A ``simple'' way to tackle the aforementioned limitations would be to
maintain on each node composing the infrastructure and for each
content, an index of all replicas (and their ``distance'').  In such
an approach, each time a new replica is created or deleted, a message
is broadcasted from the node that performed the operation (\ie the
source) to all nodes, increasing the distance information at each hop.
%
In addition to being complicated for large-scale systems, maintaining
a global view on each node is useless as there is no interest to
inform a node of the creation/removal of a replica at the opposite of
the network (each node trying to get content from the ``closest''
one).  In other words, the broadcast should be limited to a partition
of the infrastructure, (\ie the subset of nodes that has to update the
current location for this particular content). Obviously, these
partitions depend and evolve according to concurrent operations made
by nodes (replica creation/removal) as well as dynamic changes in the
infrastructure (network failures, node apparitions/leaves).

In this paper, we propose a first implementation of such a protocol.
Entitled Adaptive Scoped broadcast (\NAME), 
our protocol relies on a primitive that forwards
messages until a certain condition is reached, \ie the scope. The
scope is defined by a boolean function (predicate) that returns
whether a message should be propagated or not around its
broadcaster. In the current scenario, the stop condition is related to
the distance to the nearest replica : if the message that a node receives
indicates a content has a longer distance than that which the node
knows then the transfer of the message is useless and so stopped.
%
This primitive is used to guarantee that eventually, every node knows
its best partition, hence its closest replica, despite concurrent
events and receipt orders. Overall, \NAME is a wait-free reactive protocol for
dynamic logical partitioning.  Its overhead actually depends on
its operations and current partitions in the system. When the system
becomes quiescent, nodes eventually converge to their respective
partition and do not require further communication afterward.

\TODO{talk about the proof}

We evaluated our protocol through two simulation scenarios using
\textit{Peersim}~\cite{montresor2009peersim}. First, we confirm that
\NAME allow consistent partitioning in an ad-hoc network composed of
10K nodes.  Second, we illustrate how \NAME enables the lock down of
the traffic in dynamic inter autonomous systems.  More precisely, we
simulated a worldwilde infrastructure by duplicating the GEANT
topology - a real infrastructure spanning across Europe â€“ and by
connecting these two clusters with a high latency link: 200 ms
simulating cross-continental communications such as Europe-America.

%\input{input/figadd.tex} %% positioning (belong to problem & motivation)

The rest of this paper is organized as
follows. Section~\ref{sec:background} introduces background, and
details the motivation behind our proposal.
Section~\ref{sec:adaptive} describes the protocol behavior, as well
as the formal definition of the underlying
algorithms. Section~\ref{sec:experimentation} presents the Peersim
evaluations.  Related work is discussed in
Section~\ref{sec:related_work} and finally
Section~\ref{sec:conclusion} concludes this article and highlights a
few future works.
  

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "../paper"
%%% ispell-local-dictionary: "english"
%%% End: 
