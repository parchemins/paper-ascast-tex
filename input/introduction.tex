
\section{Introduction}

\input{input/figpartitionintuition.tex} %% positioning

There is an ongoing evlution of storing data from the cloud to the
edges of the network. Either because it is where it has been created
and it is too expensive to be transmitted through the network, or
because it has been replicated to bring data closer to the end users
~\cite{shi2016edge, foggy_cache, cachier}.
%
To favour this transition, the design and the development of building
blocks to manage data sets across Edge infrastructures have been
investigated for the last few years \cite{confais2017performance,
  confais2017object, fogstore, hasenburg2020towards}.  Although these
systems, provide good properties such as favouring network traffic
confinement by writting data locally and replicating contents
according to the effective needs, determining the location where to
get the content might be more expensive than retrieving the content
itself.
%
Indeed, those systems, when not using a centralized index stored in a
Cloud, rely on a Distributed Hash Table (DHT) across the different
nodes composing the infrastructure: When a client wants to access a
specific content, it has to perform a request to a remote process to
determine from which node(s) it will retrieve the content.  Once it has
retrieved the content, a local replica
is created to improve the performance for future accesses and the
process in charge of maintaining the index is contacted once again to reflect this
new location.
%

%This strategy has two majors drawbacks :
%\begin{itemize}
%  \item (i) the lookup penalty: the network latency to reach this
%    remote node incurs an additional delay~\cite{asrese2019measuring,
%      doan2019tracing} to get the object before
%    being able to start its downloading ;
%  \item (ii) the selection of the node(s) from which the content is
%    returned: due to the lack of information that would allow the  a request to each process storing a
%%    replica is perfomed in
%\end{itemize}

Such a protocol contradicts with the objective of Edge
infrastructures that aims at reducing the impact of the
latency as well as the volume of data passing through the network:
\begin{itemize}
  \item In addition to hot spot and partitioning issues, accessing a
    remote node to find the location(s) of a content incurs an
    additional delay~\cite{asrese2019measuring, doan2019tracing} to
    get the object, before being able to start its downloading.
  \item There is no information to select the ``best'' node among the
     possible candidates from which the content  could be
     retrieved. This results in parallel requests performed by the client node to
     each candidate with the goal of retrieving the content as efficient
     as possible.
\end{itemize}    

A ``simple'' way to tackle the aforementioned limitations would be to
maintain on each node composing the infrastructure and for each
content, an index of all replicas (and their ``distance'').  In such
an approach, each time a new replica is created or deleted, a message
is broadcasted from the node that performed the operation (\ie the
source) to all nodes, increasing the distance information at each hop.
%
In addition to being complicated for large-scale systems, maintaining
a global view on each node is useless as there is no interest to
inform a node of the creation/removal of a replica at the opposite of
the network (each node trying to get content from the ``closest''
node).  In other words, the broadcast should be limited to a partition
of the infrastructure, (\ie the subset of nodes that has to update the
current location for this particular content). Obviously, these
partitions depend and evolve according to concurrent operations made by nodes and
dynamic changes in the infrastructure (network failures, node
apparitions/leaves).

In this paper, we propose a first implementation of such a protocol.
Entitled \NAME, our protocol relies on a primitive that forwards
messages until a certain condition is reached, \ie the scope. The
scope is defined by a boolean function (predicate) that returns
whether a message should be propagated or not around its
broadcaster. In the current scenario, the stop condition is related to
the distance to the nearest replica : if the message that a node receives
indicates a content has a longer distance than that which the node
knows then the transfer of the message is useless and so stopped.
%

This primitive is used to communicate with the different nodes
according to four events: creation/removal of a replica and node
apparitions/leaves. \TODO{network failures is considered as a node leave?}

\TODO{add something about the paper work}

We evaluated our protocol through simulations using \textit{Peersim}~\cite{montresor2009peersim}. The topolgies we simulated are based on real-world ones from the Internet Toplogy
Zoo~\cite{knight2011internet}.  Our evaluation shows that \NAME is able to
provide a similar localization service when compared to a DHT-based
approach while removing the lookup penalty or to an hypothetical complete and robust broadcast. This directly translates
into faster data access as shown by our measurements, with a time
reduction from $20\%$ to $60\%$, depending on the sizes of the
objects. %\AVK[Talk about load balancing and traffic containment here]
We also show that by slightly delaying the sending of messages, \NAME
can match the number of messages of a DHT-based approach, at the cost
of a moderate increase in message sizes.

\TODO{Update the conclustion of the experiment}

%\input{input/figadd.tex} %% positioning (belong to problem & motivation)

% TODO : Use cases
While we use the distance to the closest copy in this paper, It is
notewothy that other scopes can be envisioned according to the
use-cases.  For instance, the location of a city in order to broadcast
message to all nodes in the city.  This requires nodes to store and
maintain their city location in their local state. Nodes stop
delivering and forwarding their received messages when they come from
a different city. Such a predicate can be complexified in order to
broadcast messages to all nodes in the city plus neighboring
cities. This requires nodes to overload forwarded messages the first
time they reach another city. The predicate checks if messages already
reached two distinct cities before delivery.  The predicate can even
be piggypack within the message and so be different for each
message.\TODO{Complete the use-cases}

\TODO{update the outline}
\TODO{The rest of this paper is organized as follows. Section II
  introduces background, related works and details the motivation
  behind our proposal.  Section III describes the protocol behavior,
  as well as the formal definition of the underlying
  algorithms. Section IV presents the evaluation of the A3
  implementation and provides an extensive comparison with a DHT-based
  approach. We discuss some extensions of this work and future
  directions in Section V before concluding in Section VI.}


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "../paper"
%%% ispell-local-dictionary: "english"
%%% End: 
